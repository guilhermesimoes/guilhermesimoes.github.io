<!DOCTYPE html>
<meta charset="utf-8">
<style>
html, body {
  height: 100%;
  margin: 0;
}

.container {
  height: 100%;
  display: flex;
  justify-content: space-evenly;
  align-items: center;
  color: rgba(237, 75, 26, 0.82);
}

input[type="checkbox"] {
  margin: 0;
  width: 10em;
  height: 10em;
}
</style>
<body>
<div class="container">
  <handdrawn-checkbox><input type="checkbox" checked /></handdrawn-checkbox>

  <handdrawn-checkbox></handdrawn-checkbox>
</div>

<script type="text/javascript">
"use strict";

var template = document.createElement('template');

template.innerHTML = `
  <style>
    :host {
      position: relative;
      display: inline-block;
    }

    :host svg {
      position: absolute;
      pointer-events: none;
      stroke-linecap: round;
      stroke-width: 0.5px;
    }

    :host .border {
      stroke: black;
      fill: none;
    }

    ::slotted(input) {
      opacity: 0;
    }
  </style>
  <svg viewbox='0 0 10 10'>
    <path class='border'></path>
    <path class='line' stroke='currentColor'></path>
    <path class='line' stroke='currentColor'></path>
  </svg>
  <slot></slot>
`;

class HandDrawnCheckbox extends HTMLElement {
  constructor() {
    super();
    var checkbox = this.querySelector('input[type="checkbox"]');
    if (!checkbox) {
      var defaultCheckbox = document.createElement('input');
      defaultCheckbox.setAttribute('type', 'checkbox');
      this.appendChild(defaultCheckbox);
    }
  }

  connectedCallback() {
    var checkbox = this.querySelector('input[type="checkbox"]');
    var templateClone = template.content.cloneNode(true);
    var pathEls = templateClone.querySelectorAll('.line');
    var borderEl = templateClone.querySelector('.border');
    borderEl.setAttribute('d', `M${getPoint(borderCorner1Range)} ${getPoint(borderCorner1Range)}L${getPoint(borderCorner2Range)} ${getPoint(borderCorner1Range)}M${getPoint(borderCorner2Range)} ${getPoint(borderCorner1Range)}L${getPoint(borderCorner2Range)} ${getPoint(borderCorner2Range)}M${getPoint(borderCorner2Range)} ${getPoint(borderCorner2Range)}L${getPoint(borderCorner1Range)} ${getPoint(borderCorner2Range)}M${getPoint(borderCorner1Range)} ${getPoint(borderCorner2Range)}L${getPoint(borderCorner1Range)} ${getPoint(borderCorner1Range)}M${getPoint(borderCorner1Range)} ${getPoint(borderCorner1Range)}`);
    toggleVisibility(pathEls, checkbox);

    var shadowRoot = this.attachShadow({ mode: 'open' });
    shadowRoot.appendChild(templateClone);

    checkbox.addEventListener('change', function() {
      toggleVisibility(pathEls, this)
    });
  }
}

var crossLine1Range = [0.5, 1.5];
var crossLine2Range = [8.5, 9.5];
var borderCorner1Range = [0.2, 0.8];
var borderCorner2Range = [9.2, 9.8];

function toggleVisibility(lines, checkbox) {
  var [line1, line2] = lines;

  if (checkbox.checked) {
    line1.setAttribute('d', `M${getPoint(crossLine1Range)} ${getPoint(crossLine1Range)}L${getPoint(crossLine2Range)} ${getPoint(crossLine2Range)}`);
    line2.setAttribute('d', `M${getPoint(crossLine2Range)} ${getPoint(crossLine1Range)}L${getPoint(crossLine1Range)} ${getPoint(crossLine2Range)}`);
    line1.style.strokeDasharray = line1.style.strokeDashoffset = getPathLength(line1);
    line2.style.strokeDasharray = line2.style.strokeDashoffset = getPathLength(line2);

    setTimeout(() => {
      line1.style.transition = line2.style.transition = 'stroke-dashoffset 200ms ease';
      line2.style['transition-delay'] = '200ms';
      line1.style.strokeDashoffset = line2.style.strokeDashoffset = 0;
    }, 10);
  } else {
    line1.style.strokeDashoffset = getPathLength(line1);
    line2.style.strokeDashoffset = getPathLength(line2);
  }
}

function getPathLength(path) {
  return Math.ceil(path.getTotalLength()) + 1; // Handle rounding issues
}

function getPoint(range) {
  var [start, end] = range;
  var diff = end - start;
  return +(start + Math.random() * diff).toFixed(2);
}

customElements.define('handdrawn-checkbox', HandDrawnCheckbox);
</script>
</body>
